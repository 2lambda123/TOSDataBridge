<!DOCTYPE HTML>
<html LANG="en-US" DIR="LTR">
<head>
<title> Python Tutorial </title>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
</head> 
<body>


 <style>
    #header1
    {
        margin: 10px;
        margin-bottom: 30px;
        text-align: center;
        padding-bottom: 10px;
        font-size: 28px;
        border-bottom: solid;
        border-bottom-width: thick;
    }
    #update_warn
    {
        margin: 10px;
        margin-bottom: 30px;
        text-align: center;
        padding-bottom: 10px;
        font-size: 28px;   
    }
    .bold
    {
        font-weight: 900;
    }
    .basictext
    {
        font-size: 18px; 
        font-weight: 500;
    }
    .subheader1
    {
        margin-left: 0px;
        margin-top: 0px;
        position: relative;
        font-size: 20px;
        font-weight: 700;
        border-bottom: solid;       
    }
    .subpara1
    {
        position: relative;
        width: auto;
        height: auto;              
        margin: 10px;
        top: 0px;
        left: 0px;
    }
    .block1
    {
        margin: 10px;      
        text-align: left;
        width: auto;             
        padding: 10px;
    }
     .auto-style1
     {
         font-weight: normal;
     }
    </style>
   
<h1 id = "header1" > TOSDataBridge&nbsp; :::&nbsp; Python Tutorial <br /></h1>

<div id = "update_warn" > <strong>!! UPDATE IN PROGRESS !!</strong> - This is an old tutorial, it is inconsistent 
    with recent updates to the tosdb package. It still shows most of the basic functionality for administrating
    the library and interactiving with the (non virtual) TOSDB_DataBlock interface.</div>

<div class = "subpara1 basictext">
    Make sure you've read and completed the necessary steps in the section 'Getting Started' to create
    and load the Service. Once you've done that and you've correctly gotten through step #2 in 
    'The Python Wrapper In A Nuthell' your screen should look something like this (assuming _tosdb.pyd 
    built correctly and you didn't use one of the alternatives provided.)
</div>
<img src="PyTut1.png" style="margin:10px" />
<div class = "subpara1 basictext">
    The next two screen-shots will show the various ways to load tosdb.py. The first way, shown 
    directly below is to import it as you would any other python library and manually initialize 
    and connect to the underlying DLL. 
    <ul>
        <li> First open python as shown or open a GUI like IDLE and use the standard technique of importing 
        the library. Next call the init() function with either a &#39;root&#39; or &#39;dllpath&#39; keyword 
        argument. The dllpath argument should, not surprisingly, be the absolute path of the main client 
        library tos-databridge-0.1[].dll. The root argument will walk the directory tree from that location 
        looking for: a) any of the non-debugging libraries that match the python build (32 or 64 bit), b) 
        the most recent versions of the library, and if necessary, c) the most recently updated one available. 
        Using the root of the the installation path (C:/tos-databridge in this case) works fine.</li>
        <li> If everything goes well you should see the three + confirmation messages; If you load the 
        client library but the Service isn&#39;t running you get a &quot;- Failed to Connect to 
        Service \ Engine &quot; message like in third init attempt below.</li>
        <li> The connect() method will attempt to (re)connect you, returning the status. After our first 
        call to connect failed we re-started the Service by using the &#39;SC start TOSDataBridge&#39; 
        command from an admin shell and called it again. You can also use the connected() call to see what 
        the status is.</li>
        <li> The clean_up() method does just that, it tells the underlying library to close all blocks 
        and signal the Service to decrement the StreamBuffer ref-counts, closing them if necessary. In 
        some cases clean_up() doesn&#39;t need to be called as the TOS_DataBlock&#39;s __del__() method 
        may signal the library, or the DllMain() function of the DLL will handle cleanup BUT THIS 
        ISN&#39;T GUARANTEED. <strong> It is strongly recommended that clean_up() be called before exiting 
        your python program.</strong> If you can&#39;t you should either open the tos-databridge-shell[].exe, 
        call Connect followed by DumpBufferStatus to get a dump file that can show if any resources have been 
        leaked and/or just stop and restart the Service. </li>
    </ul>
</div>
<img src="PyTut2.png" style="margin:10px" />
<div class = "subpara1 basictext">
    The next screen-shot shows the command to start tosdb.py directly in interactive mode. Rather than 
    import the library and calling init you pass either a &#39;--path&#39; arg which is the same as 
    &#39;dllpath&#39; in the last example or a &#39;--root&#39; arg.&nbsp; If you pass -n or --noinit 
    init() will not be called and you&#39;ll have to do it manually, as above. If you pass none of these 
    args, after a warning, the default root=&#39;C:\&#39; version of init() will be called which, for 
    obvious reasons, is not recommended.
</div>
<img src="PyTut3.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    Finally we're at the good stuff. Like the underlying library we store all data in 'blocks': 
    the TOS_DataBlock class. Construct with a size, date_time value (boolean), and a timeout value that you 
    shouldn't worry about right now. We&#39;ll get started by creating a block that holds 1000 elements and 
    records a DateTime Stamp with each.
</p>
<p>
    The first thing we need to do is add some items(securities) and topics(fields). The names are a little 
    confusing but we started with the DDE terminology and it just stuck.  In this case we'll add two 
    popular index ETFs: one for the S&P 500, the other for the NASDAQ 100. You may be surprised to notice 
    that after we add these two items the items() method returns an empty list. This is because the added 
    items are stored in a pre-cache until a topic arrives. How can we create a data-stream if we don&#39;t 
    have any topics? 
</p>
<p>
    *[This pre-caching behavior also works the other way: if we remove all the items (topics) the remaining 
    topics (items) will be sent into the pre-cache and appear not to exist any longer. This may all seem 
    silly and problematic but it makes things much easier and cleaner to implement. The only problem, which 
    we haven&#39;t fixed yet, is providing C versions of the calls to query the strings in the pre-cache 
    so you can know what&#39;s there. For the time being you just have to anticipate this feature and 
    code accordingly.]
</p>
<p>
    Let&#39;s add some topics but this time do it slightly differently, by unpacking a list called fields. 
    You&#39;ll need to pass valid Topics to the block. If you were able to set up _tosdb.py (no 'NUCLEAR' 
    option) when installing tosdb.py the global tuple TOPICS (not shown here) should provide all the valid 
    strings you can pass. An invalid topic will be ignored (unlike an invalid item.) You&#39;ll now notice 
    a call to the items() method returns the ones we added earlier.
</p>
<p>
    To get a summary of the block we can call its info() method which is a lightly more readable version of 
    its built-in __dict__ attribute. As soon as the add_topics call completes (there will be a lag relative 
    to the number of topics because of a SendMessageTimeout() issue discussed in the README) the block will 
    start taking in data from the server. The stream_occupancy call will tell us how much has come in. In 
    this case we don't want to take all 1000 values so we'll use set_block_size to adjust the block to 150.
</p>

</div>
<img src="PyTut4.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    There are a handful of global functions in the module that may or may not be useful to you. You should know 
    get_block_count, get_block_limit, and set_block_limit to avoid issues when creating multiple blocks. 
    Internally we maintain a flexible limit to how many blocks can be created in the library. Below we'll 
    change the default of ten to two and try to create a third block which the underlying library does not like.
</p>
<p>
    Lets get rid of the second block. The result of the get_block_count call ( 1 ) shows db2&#39;s __del__() 
    method was called and the block was destroyed by the library. Some of the other global functions are shown 
    as well.
</p>
</div>
<img src="PyTut5.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p> 
    OK, lets pull some data from the block.  The simplest thing we can do is call the get method with no extra 
    args (besides the necessary item and topic strings) to get the most recent data-point for that particular 
    stream.
</p>
<p> TOS_DataBlock&#39;s __str__() method is defined to return a formatted version of the most recent data, 
    which is shown by the print() function ( later on we&#39;ll refer to this as a a total frame.) Next 
    we&#39;ll add topic BA_SIZE to get a string of Bid x Ask sizes and some new symbols, including the 
    appropriately named INVALID_ITEM which, as mentioned earlier, is added to the block. Let's remove it 
    with remove_items().
</p>
<p> Since we created the block with the date_time arg set to True we can pull a TOS_DateTime object out by 
    passing True to the get call. 
</p>
</div>
<img src="PyTut6.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    We created the TOS_DateTime object to provide as much info as possible without being a burden. It's 
    implemented as a named tuple so you can easily get micro or second data, for instance, by accessing 
    its .micro or .sec attributes, respectively. (Keep in mind, the get() method returns the DateTime 
    object as index 1 of a 2-tuple.) You can subtract them to get a DateTimeDiff namedtuple: similar to 
    TOS_DateTime; without the month and year fields; with a sign field. You can also add and subtract 
    integral micro_second values to return a new TOS_DateTime object, leaving the original alone. All the 
    basic comparison operators are provided as well.  
</p>
</div>
<img src="PyTut7.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    Let&#39;s increase our block size to 10000 and try to use the get method to pull other index values. 
    First we'll try to get the 501st most recent value. Because the check_indx parameter is set to True by 
    default it raises an error; there aren't 501 elements in the stream yet. If we disable it a NULL(0)* 
    value is returned.
</p>
<p>
    The stream_snapshot() method is probably the most useful: it lets you pull large collections of data 
    out of the stream. The default call is going to try to pull the whole stream(in this case 10000 
    elements) with date_time set to False and smart_size set to True. As you can see when smart_size 
    is set to True its not going to pull more than the occupancy, in this case only 397 rather than 
    all 10,000. If you set smart_size to False you&#39;ll get all the elements (in this case 10,000), 
    with the unavailable set to NULL(0)*. 
</p>
<p>
    You can use any beginning and ending index within the size of the block. Remember the index values 
    are INCLUSIVE so beg=0 and end = 3 will pull 4 items. Negative indexes start from the end(least 
    recent data) at a value of -1. You can set date_time to true just like with the get() method to pull 
    out a list of 2-tuples.
</p>
<p>* not guaranteed to be 0 in all cases, to be safe you should assume the results to be undefined</p>
</div>
<img src="PyTut8.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    Lastly let&#39;s look at the 'frame' calls: item_frame(), topic_frame(), and total_frame().  The 
    concept of frames is explained in depth in the README; for our purposes just think of them as ways of 
    viewing the most recent data of a block. 
</p>
<p>
    First we'll call topic_frame for item &quot;SPY&quot; to return ALL the topic values for that 
    item. As you can see we get a unique namedtuple of all the values. Likewise if we call 
    item_frame and pass a particular topic we&#39;ll get a namedtuple holding ALL the item values. 
    In this case we pull all the most recent LAST values as a unique namedtuple. The total_frame() call 
    is a way to get ALL the most recent data in the block( similar to what the __str__() value returns) 
    as a dictionary of namedtuples returned from the topic_frame() method. We show an easier to read 
    version by looping through allVals and printing each entry.
</p>
<p>
    <strong> NOTE: After taking these screen-shots we changed the item_labels and topic_labels argument 
    name to simply 'labels'. We'll refer to them as the latter even if the screen-shot shows one of the 
    former.</strong>
</p>
<p>
    These calls can get a little confusing because of the date_time and labels boolean arguments you can 
    pass. Like the get() and stream_snapshot() methods date_time is False by default but if set to True a 
    sequence of 2-tuples with TOS_DateTime will be returned as we show with lastValsDT: the returned 
    namedtuple of 2-tuples from an item_frame() call.
</p>
<p>
    By default the labels boolean arg is set to True. Shutting them off changes the return type to a simple 
    list but makes the data tough(er) to interpret, as shown by lastValsNoLabels.
</p>
</div>
<img src="PyTut9.png" style="margin:10px" />
<div class = "subpara1 basictext">
<p>
    It's important to note that there are a number of different calls for pulling data, and a number of 
    optional arguments to use. In many cases these arguments will determine the return type of the call. 
    For instance the item and topic 'frame' calls can return a namedtuple of 2-tuple, a namedtuple, a list 
    of 2-tuple, or a simple list depending on the combination of date_time and labels values passed. 
    Fortunately python accommodates for this return type overload.
</p>
<p>
    That's it for the basics. When you're done it's HIGHLY RECOMMENDED you at least call the global 
    clean_up() function to avoid leaks and interference with any other instances of the underlying library 
    running. 
</p>

</div>
<footer style="text-align:center" > Copyright (C) 2014 Jonathon Ogden </footer>
</body>
</html>