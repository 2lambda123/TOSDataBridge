<!DOCTYPE HTML>
<html LANG="en-US" DIR="LTR">
<head>
<title> TOSDataBridge README </title>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
</head>
<body>
<style>
    #header1
    {
        margin: 10px;
        text-align: center;
        padding-bottom: 10px;
        font-size: 28px;
        border-bottom: solid;
        border-bottom-width: thick;
    }
    #sub_header1
    {
        margin: 10px;
        text-align: center;
        padding-bottom: 10px;
        font-size: 20px;        
    }
    .bold
    {
        font-weight: 900;
    }
    .basictext
    {
        font-size: 18px; 
        font-weight: 500;
    }
    .smalltext
    {
        font-size: 15px;
        font-weight: 500;
    }
    .cb
    {
        clear: both;
        height: 0px;
    }
    .left_col
    {         
        vertical-align: top;
        width: 260px; 
        float: left;
    }
     .right_col
    {            
         vertical-align: top;          
         font-weight: 400;  
         margin-left: 270px;          
    }
    .subheader1
    {
        margin-left: 0px;
        margin-top: 0px;
        position: relative;
        font-size: 20px;
        font-weight: 700;
        border-bottom: solid;       
    }
    .subpara1
    {
        position: relative;
        width: auto;
        height: auto;              
        margin: 10px;
        top: 0px;
        left: 0px;
    }
    .block1
    {
        margin: 10px;      
        text-align: left;
        width: auto;             
    }
    .subblock1
    {
        padding: 10px;
    }
    .listitems1, .listitems2, listitem3
    {
        list-style: none;
        margin-right: 4px;
        margin-top: 4px;
        margin-bottom: 4px;
    }
    .listitem2
    {
        list-style: circle;
        margin: 8px;
    }
    .listitems3
    {
        list-style: decimal;
        margin-top: 8px;
        margin-bottom: 8px;
    }
    .func_stub
    {
        margin-right: 1px;
        margin-right: 4px;
        padding: 1px;     
        width:auto;
        border: dotted;
        border-width: thin;   
        color: red;     
    }
    .note_block
    {
        width: 75%;
        margin: 20px;
        margin-left: auto;
        margin-right: auto;
        padding: 10px;
        border: solid;
        border-width: thin;
        color: black;
    }


    </style>

<h1 id = "header1" > TOSDataBridge&nbsp; :::&nbsp; README <br /><span id = "sub_header1" > 
    Version 0.1 </span></h1>

<div class = "block1 " >
<div class = "subpara1 basictext"> 
<p> 
    &nbsp;&nbsp;&nbsp;&nbsp; TOSDatabridge (TOSDB) is an open-source collection of resources for 'scraping' 
    real-time streaming data off of TDAmeritrade's ThinkOrSwim(TOS) platform, providing C, C++, and Python 
    interfaces. Users of the TOS platform - with 
    some basic programming/scripting knowledge -  can use this tool to populate their own databases with
    market data; perform specialized, low-level, and efficient analysis on large data-sets 
    in real-time; test and debug other financial apps; or even build extensions on top of it .</p>
<p> 
    &nbsp;&nbsp;&nbsp;&nbsp; TOSDB uses TOS&#39;s antiquated, yet still useful, DDE feature directly through the 
    Windows API. The C / C++ interfaces are implemented as a shared library(DLL) that communicates with a back-end
    Windows Service. This allows any number of instances loaded into client code to run, sharing this 
    Service. The Python interface wraps this library in a more object-oriented, user-friendly format 
    providing an interactive environment for easy access to the low(er)-level calls. </p>
<p> 
    &nbsp;&nbsp;&nbsp;&nbsp;  
    Obviously the core implementation is not portable, but the python interface does 
    provides a thin virtualization layer over TCP. A user running Windows in a 
    Virtual Machine, for instance, can expose the exact same python interface to a 
    different host system running python3.</p>
<p><i>
    &nbsp;&nbsp;&nbsp;&nbsp; TOSDB is released under the<strong> GNU General Public License(GPL);</strong> 
    a copy (LICENSE.txt) should be included. If not, see 
    <a href="http://www.gnu.org/licenses">http://www.gnu.org/licenses</a>. The author reserves the right to 
    issue current and/or future versions of TOSDB under other licensing agreements. Any party that wishes 
    to use TOSDB, in whole or in part, in any way not explicitly stipulated by the GPL, is thereby required 
    to obtain a separate license from the author. The author reserves all other rights</i>.</p>
<p><i>
    &nbsp;&nbsp;&nbsp;&nbsp; This program is distributed in the hope that it will be useful, but WITHOUT ANY 
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See 
    the GNU General Public License for more details. </i></p>
<p><i>
    &nbsp;&nbsp;&nbsp;&nbsp; By choosing to use the software - under the broadest interpretation of the term 
    "use" - you absolve the author of ANY and ALL responsibility, for ANY and ALL damages incurred; including, 
    but not limited to, damages arising from the accuracy and/or timeliness of data the software does, or 
    does not, provide. </i></p>
<p><i>
    &nbsp;&nbsp;&nbsp;&nbsp; Furthermore, TOSDB is in no way related to TDAmeritrade or affiliated parties; 
    users of TOSDB must abide by their terms of service and are solely responsible for any violations therein.</i></p>
</div>
</div>


<div class = "block1" >
<div class = "subheader1" > Contents</div> 
<div class = "subpara1 basictext"> 
<ul>
    <li class = "listitems1 basictext"> <i>/include </i>
        <ul>                
            <li class = "listitems2 smalltext"> All the header files. Most are used by the back-end and 
            don&#39;t need to be included in your code unless you plan to change or replace the current 
            modules and/or add your own. C or C++ code must include the tos-databridge.h header; C++ code 
            needs to make sure that containers.hpp and generic.hpp are in the include path. </li>
        </ul>
    </li>
    <li class = "listitems1 basictext"><i>/src</i> 
        <ul >        
            <li class = "listitems2 smalltext">All the source files. If compiling from source simply open 
            the .sln file inside /VisualStudioBuild; select the configuration and platform; and build.</li>          
        </ul>
    </li>
    <li class = "listitems1"><i>/symbols </i>
        <ul>
            <li class = "listitems2 smalltext"> All the .pdb and .idb files for debugging / disassembly in 
            the appropriate configuration folder. Add these directories to 
            DEBUG->Options\Settings->Debugging->Symbols. NOTE: to limit total size we don't include files 
            for debug builds.</li>
        </ul>
    </li>    
    <li class = "listitems1"><i>/bin </i>
        <ul>
            <li class = "listitems2 smalltext">All the compiled binaries by build type. NOTE: to limit 
            total size we don't include debug builds.</li>
        </ul>
    </li>

    <li class = "listitems1"><i>/VisualStudioBuild</i> 
        <ul>
            <li class = "listitems1 smalltext">The complete Visual Studio solution with properties, 
            pre-processor options, relative links etc set, 
            ready to be compiled. </li>
        </ul>
    </li>
    <li class = "listitems1"><i>/python</i>
        <ul>
            <li class = "listitems1 smalltext">The relevant files to the python Wrapper. </li>
        </ul>
    </li>
    <li class = "listitems1"><i>/docs</i>
        <ul>
            <li class = "listitems1 smalltext">Documentation, Tutorials, Licenses etc. </li>
        </ul>
    </li>
</ul>
</div>
</div>

<div class = "block1" >
<div class = "subheader1" > Build Notes</div> 
<ul>
    <li class = "listitem2 basictext"> Object code and logs are placed into an intermediate sub-directory 
    of /VisualStudioBuild of form /$(Configuration)/$(Platform). After the object code is linked the 
    binaries are sent to a sub-directory of /bin of form /$(Configuration)/$(Platform) and the symbol 
    files are sent to /symbols/$(Configuration). Having all the binaries together is convenient but can 
    cause build dependency issues. If you notice strange file related warnings or linking errors try 
    clean-solution followed by build-solution to start fresh.</li>
    <li class = "listitem2 basictext"> Originally there was an option to compile with MinGW but certain 
    features used in the current code are not implemented so it's suggested to use Visual Studio rather 
    than re-write the threaded portions et al. </li>
    <li class = "listitem2 basictext">  A debug build with VLD_ defined will use virtual leak detector 
    (assuming you&#39;ve followed the other instructions for using it.).</li>
    <li class = "listitem2 basictext"> Defining SPPRSS_INPT_CHCK will disable most of the internal 
    C-string checks for overflows, NULL terminators etc. (not recommended).</li>
    <li class = "listitem2 basictext">  There are 32 and 64 bit (Win32 and x64, not ARM) binaries 
    included along with the relevant configurations in the VisualStudio solution. Debug versions have a 
    &quot;_d&quot; suffix to avoid collisions. It&#39;s up to the user to choose and use the correct 
    builds for ALL modules. The python library will search for the underlying DLL (-x64 vs. -x86) that 
    matches the bit size returned by the log2 of its sys.maxsize() call, so check that its the correct 
    build if you get a dll error during the init() call.</li>
    <li class = "listitem2 basictext">  The core implementation has been tested, and 'works', on 
    Windows 7 SP1, Windows Server 2008 R2, and Vista SP2. The virtual python layer/interface has been 
    tested on Windows 7 and Debian/Linux-3.2. There was a problem running the TOS platform itself on 
    Windows Server 2012 R2: crashing with the Java VM throwing an EXCEPTION_ACCESS_VIOLATION from 
    glass.dll. (Attempts to fiddle with permissions, use different versions of jre etc. were fruitless.)</li>
</ul>
</div>

<div class = "block1" >
<div class = "subheader1" > Modules </div> 
<div class = "subpara1 basictext"> 
<ul>
    <li class = "listitems1"> <i>:: tos-databridge-serv-x86.exe / -x64.exe ::</i>
        <ul>
            <li class = "listitems2 smalltext"> The service process that spawns and controls the main 
            engine described below. This program should be run as a typical windows service. In certain 
            cases, debugging for instance, you can pass the --noservice arg to run as a pure executable. 
            This module runs as SYSTEM, with such privileges; as such its intended role is very limited.</li>
        </ul>
    </li>
    <li class = "listitems1"> <i>:: tos-databridge-engine-x86.exe / -x64.exe ::</i>
        <ul>
            <li class = "listitems2 smalltext"> The main engine that interacts with the TOS platform. It 
            is spawned from tos-databridge-serv.exe with a lowered integrity level (system-to-high or 
            system-to-medium) and drastically reduced privileges to   interact with the TOS platform 
            (as standard user or admin). It is also able to communicate with our shared library(below) 
            running in a normal user context at medium integrity level.
        </li>
    </ul>
        </li>
    <li class = "listitems1"> <i>:: tos-databridge-0.1-x86.dll / -x64.dll ::</i>
        <ul>
            <li class = "listitems2 smalltext">The main library that client code will use to access TOSDB. It's 
            part light-weight database(s) and part interface.  Review tos-databridge.h, and the sections below,  
            for all the necessary calls, types, and objects. </li>
        </ul>
    </li>
    <li class = "listitems1"> <i>:: _tos-databridge-shared-x86.dll / -x64.dll ::</i>  
        <ul>
            <li class = "listitems2 smalltext">A back-end library used by the previous two modules. It 
            provides the concurrency and IPC objects used in both modules as well as the Topic-String mapping. 
            It doesn't need to be linked to your code but it needs to be in the right path for other modules 
            that are dependent on it. (see below)</li>
        </ul>
    </li>
    <li class = "listitems1"> <i>:: _tos-databridge-static-x86.lib / -x64.lib :: </i> 
        <ul>
            <li class = "listitems2 smalltext">The other back-end library that provides some basic logging 
            and utility functions shared between the modules.</li>
        </ul>
    </li>
    <li class = "listitems1"> <i>:: tosdb/ :: </i>
        <ul>
            <li class = "listitems2 smalltext">The python wrapper built on <i>tos-databridge-0.1-x86.dll 
            / -x64.dll</i>. It provides a slightly more object oriented, simplified means of 
                accessing the core functionality. </li>
        </ul>
    </li>
    <li class = "listitems1"> <i>:: tos-databridge-shell-x86.exe / -x64 :: </i> &nbsp 
        <ul>
            <li class = "listitems2 smalltext">This is a crass &#39;shell&#39; used to interact directly 
                with the library calls for testing and debugging. </li>
        </ul>
    </li>
</ul>
<div class = "subpara1 smalltext" style="padding-bottom: 15px"> * Going forward we&#39;ll exclude the build 
suffix (i.e. -x64 ) for syntactic convenience. We&#39;ll replace it with [] in an attempt to avoid confusion. 
Unless stated explicitly, if sensible, assume that both builds apply.</div>  
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > Getting Started </div>
<div class = subblock1 ">
<div class = "subpara1 basictext"> &nbsp&nbsp;&nbsp;&nbsp; The following sections will outline how to setup 
and use TOSDB's basic functionality. If you plan to use the Python wrapper make sure to find out which 
build it is and use the same build version of the tos-databridge 
modules in the steps to follow. At the end of this section is a screen-shot of all the relevant commands for 
using the x64 binaries.
<ul>
    <li class = "listitems3 "> First make sure you move the unzipped tos-databridge folder to its permanent 
    location(our&#39;s is in C:/ for convenience.) If you change it in the future you&#39;ll need to redo 
    some of these steps because the Service module relies on an absolute path. Next compile the appropriate 
    binaries if building from source.(If you aren&#39;t compiling from source, don&#39;t worry, there are 
    pre-compiled versions in the /bin folder). There are two pieces of info you&#39;ll need to pass to 
    the setup script. The first is the build version you are going to use 32-bit(x86) or 64-bit(x64). Make 
    sure you don&#39;t mix and match in future steps, especially when using the python wrapper because it 
    will choose a version that matches its own build. (You may want to jump down to 'The Python 
    Wrapper In a Nutshell' section now if unsure how to find this info.) The second is whether your TOS platform is 
    running under elevated privileges: does it ask for an admin password before starting or can you simply 
    run it from your standard (non-admin) user account ? </li>

    <li class = "listitems3 "> Open a command shell with Admin Privileges (right-click on cmd.exe and click 
    &#39;run as administrator&#39;). Navigate to the tos-databridge root directory. (If you don't need a custom 
    session) enter one of the following commands that matches your situation: &quot;tosdb-setup.bat x86&quot; or 
    &quot;tosdb-setup.bat x64&quot; or &quot;tosdb-setup.bat x86 admin&quot; or &quot;tosdb-setup.bat x64 admin&quot;. 
    (SEE THE SCREEN-SHOT BELOW). If you do need a custom session - for instance, you are accessing Windows remotely - 
    add the session id (probably '2') as the last argument.  Check that tos-databridge-engine.exe[] 
    - and whatever 'client' code that's been created - is running in the same session as the ThinkOrSwim platform. In 
    most cases this will is session 1 and won't require this argument. </li>

    <li class = "listitems3 "> The setup script is going to do a few things: 1) move the 
    _tos-databridge-shared[].dll(s) to the Windows Directory. This is generally not the best idea but we 
    don&#39;t know the details of what and where you&#39;ll link from so we are doing this for convenience. 
    If you create your own executables you can update your PATH environment variable or setup application 
    specific paths in the registry and move this file there; 2) make sure you have the appropriate run-time 
    libraries installed; if not the appropriate redist executable will be run to install them. (If this 
    fails you can do this manually by downloading the most recent VC++ Redistributable from Microsoft); 
    and 3) create the Windows Service.</li>

    <li class = "listitems3 "> Before we continue it&#39;s a good idea, possibly 
        necessary, to add the tos-databridge binaries, or the whole directory, to your 
        anti-virus&#39;s &#39;white-list&#39;.<strong> There&#39;s a good chance that if you don&#39;t do 
    this tos-databridge-engine[].exe, at the very least, may be stopped and/or deleted for 
    &#39;suspicious&#39; behavior (the latter happened while trying to test on a Vista system running Norton.) </strong></li>

    <li class = "listitems3 ">After the Windows Service has been successfully created run 
    <em>C:\&gt; &#39;SC start TOSDataBridge&#39; </em> which, you guessed it, will start the service. 
    Returned text should confirms this; task-manager or the services plug-in should show the name 
    TOSDataBridge with a status of Running. (SEE THE SCREEN-SHOT BELOW) Keep in mind, once you stop the 
    service you&#39;ll have to start it again the next time you want to run your program or the python 
    wrapper. Some other commands you may need:
    <ul>
        <li class = "listitems3"><em>&#39;SC stop TOSDataBridge&#39;</em> - this will stop the service. 
        All the data collected so far will still exist but the engine will sever its connection to TOS 
        and exit.&nbsp; It should no longer be shown as a running process and its status should be Stopped.</li>
        <li class = "listitems3"><em>&#39;SC pause TOSDataBridge&#39;</em> - this will pause the service. 
        All the data collected so far will still exist but the engine will stop recording new data in the 
        buffers. It should still be shown as a running process but its status should be Paused. It&#39;s 
        not recommended you pause the service.</li>
        <li class = "listitems3"><em>&#39;SC continue TOSDataBridge&#39;</em> - this should continue a 
        paused service. All the data collected so far will still exist, the engine will start recording new 
        data into the buffers, but you will have missed any streaming data while paused. The service should 
        return to the Running state.</li>
        <li class = "listitems3"><em>&#39;SC delete TOSDataBridge&#39;</em> - if you compile a new version 
        you should use this to delete the old version and go back to step #1.</li>
    </ul>

    </li>
    <li class = "listitems3 "><b>(SKIP IF ONLY USING PYTHON) </b>Include the tos_databridge.h header in your code ( if its C++ make sure the 
    compiler can find containers.hpp and generic.hpp ) and adjust the link settings to import the 
    tos-databridge-0.1-[].lib stub. (If you run into trouble review the VisualStudio settings for 
    tos-databridge-shell[].exe as they should resemble what you&#39;re trying to do.)</li> 
    <li class = "listitems3 "><b>(SKIP IF ONLY USING PYTHON) </b>Jump down to the next section for some of the basic library calls to add to 
    your program. </li>
    <li class = "listitems3 ">Make sure the TOS Platform is running, execute your program. </li>
</ul>
<div> <img src="./SCss1.png" />  </div> 
</div>
</div>
</div> 

<div class = "block1 basictext" >
<div class = "subheader1" > C/C++ Interface Calls ::: Part I - Administrative Calls </div> 
<div class = subblock1 ">
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Once the Service is running start by calling <span class = "func_stub"> 
    TOSDB_Connect() </span> which will return 0 if successful. Call the Library function 
    <span class = "func_stub"> TOSDB_IsConnected() </span> to see if you are &#39;connected&#39; to the 
    TOSDataBridge service. (1 == True; Don't get confused here, IsConnected() returns an unsigned int that 
    represents a boolean value; most of the other C admin calls return a signed int to indicate error(non-0) 
    or success(0). Boolean values will be represented by unsigned int return values for C and bool values 
    for C++.) Generally <span class = "func_stub"> TOSDB_Disconnect() </span> will not need to be called as 
    it's called automatically when the library is unloaded.  
</p>
<div class = "note_block basictext"> 
    <strong>NOTABLE CONVENTIONS </strong>The C calls, except in a few cases, don't return values but populate 
    variables, arrays/buffers, and arrays of pointers to char buffers. The 'dest' argument is for primary 
    data, and is a pointer to a variable or an array/buffer when followed by argument 'arr_len' - which 
    takes its size in array elements. The String versions of the calls take a char** argument, followed by 
    arr_len for the number of char*s, and str_len for the size of the buffer each char* points to (obviously 
    they should all be &gt;= to this value). NOTE: the poorly named str_len arg is the size of the total char 
    buffer you are passing.  If the call requires more than one array/buffer besides &#39;dest&#39; 
    (the Get...Frame... calls for instance) it assumes an array length equal to that of &#39;arr_len&#39;.  
    If it is of type char** you need to specify a char buffer length just as you do for the initial char**.
</div>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    TOSDB's main organizational unit is the 'block'( struct TOSDBlock in client.hpp ) 
    - it's important functionally and conceptually. The first thing client code does is call 
    <span class = "func_stub"> TOSDB_CreateBlock() </span> passing it a unique ID(<= TOSDB_BLOCK_ID_SZ) that 
    will be used to access it throughout it's lifetime, a size(how much historical data is saved in the block's 
    data-streams), a flag indicating whether it saves DateTime in the stream, and a timeout value used for its 
    internal waiting/synchronization. When you no longer need the data in the block <span class = "func_stub"> 
    TOSDB_CloseBlock() </span> should be called to deallocate its internal resources or <span class = "func_stub"> 
    TOSDB_CloseBlocks() </span> to close all that currently exist. If you lose track of what's been created use 
    the C or C++ version of <span class = "func_stub"> TOSDB_GetBlockIDs() </span>. Technically 
    <span class = "func_stub"> TOSDB_GetBlockCount() </span> returns the number of RawDataBlocks allocated 
    (see below), but this should always be the same as the number of TOSDBlocks.
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Within each &#39;block&#39; is a pointer to a RawDataBlock object which relies on an internal factory to return a constant pointer to a 
    RawDataBlock object. Internally the factory has a limit ( the default is 10 ) which can be adjusted with 
    the appropriately named admin calls <span class = "func_stub"> TOSDB_GetBlockLimit() </span> 
    <span class = "func_stub"> TOSDB_SetBlockLimit() </span> 
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Once a block is created, items and topics are added. As mentioned earlier 
    topics are the TOS fields (e.g. LAST, VOLUME, BID ) and items are the individual symbols 
    (e.g. IBM, GE, SPY). <span class = "func_stub"> TOSDB_Add() </span>
    <span class = "func_stub"> TOSDB_AddTopic() </span> <span class = "func_stub"> TOSDB_AddItem() </span> 
    <span class = "func_stub"> TOSDB_AddTopics() </span><span class = "func_stub"> TOSDB_AddItems() </span> 
    There are a number of different versions for C and C++, taking C-Strings(const char*), arrays of 
    C-Strings(const char**), string objects(std::string), TOS_Topics::TOPICS enums, and/or specialized sets 
    (str_set_type, topic_set_type) of the latter two. Check the prototypes in tos_databridge.h for all the 
    versions and arguments.
</p>
<div class = "note_block basictext">
    <b> IMPLEMENTATION NOTE </b> Items added before any topics exist in the block - or vice versa - will be 
    pre-cached, i.e. they will be visible to the back-end but not to the interface until a topic or item is 
    added (see 'Important Details and Provisos' section below); likewise if all the items or topics in a block
    or removed(thereby leaving only topics or items, respectively.) To view the pre-cache use the C++(only) 
    calls <span class = "func_stub"> TOSDB_GetPreCachedTopicNames() </span> 
    <span class = "func_stub"> TOSDB_GetPreCachedItemNames() </span> 
    <span class = "func_stub"> TOSDB_GetPreCachedTopicEnums() </span> 
</div>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Currently its only possible to remove individual items
    <span class = "func_stub"> TOSDB_RemoveItem() </span> and topics 
    <span class = "func_stub"> TOSDB_RemoveTopic() </span> or close the whole block. 
    <span class = "func_stub"> TOSDB_CloseBlock() </span>
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    As mentioned, the size of the block represents how large the data-streams are, 
    i.e. how much historical data is saved for each item-topic (each entry in the block has the same size; 
    if you prefer different sizes create a new block). Call 
    <span class = "func_stub"> TOSDB_GetBlockSize() </span> to get the size and 
    <span class = "func_stub"> TOSDB_SetBlockSize() </span> to change it.
</p>
<div class = "note_block basictext">
    <b> IMPLEMENTATION NOTE </b> The use of the term size may be misleading when getting into implementation 
    details.  This is the size from the block's perspective and the bound from the data-stream's perspective. 
    For all intents 
    and purposes the client can think of size as the maximum number of elements that can be in the block and 
    the maximum range that can be indexed. To get the occupancy (how much valid data has come into the stream) 
    call <span class = "func_stub"> TOSDB_GetStreamOccupancy() </span>.
</div>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    To find out the the items / topics currently in the block call the C or C++ 
    versions of <span class = "func_stub"> TOSDB_GetItemNames() </span>  
    <span class = "func_stub"> TOSDB_GetTopicNames() </span> 
    <span class = "func_stub"> TOSDB_GetTopicEnums() </span> or if you just need the number 
    <span class = "func_stub"> TOSDB_GetItemCount() </span> 
    <span class = "func_stub"> TOSDB_GetTopicCount() </span>.
    To find out if the block is saving DateTime call the C or C++ versions of 
    TOSDB_IsUsingDateTime().     
</p>

<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Because the data-engine behind the blocks handles a number of types it's 
    necessary to pack the type info inside the topic enum. Get the type bits at compile-time with 
    TOS_Topics::Type< ...topic enum... >::type or at run-time with
    <span class = "func_stub"> TOSDB_GetTypeBits() </span>, checking the bits with  the appropriately 
    named TOSDB_[ ]_BIT constants in tos_databridge.h. (e.g. if( TOSDB_TypeBits( "BID" ) == TOSDB_INTGR_BIT) 
    then treat the data as a long (def_size_type). Make sure you don't simply check a bit with logical AND 
    when what you really want is to check the entire type_bits_type value; in this example checking for 
    the INTGR_BIT will return true for def_size_type AND ext_size_type.)
    <span class = "func_stub"> TOSDB_GetTypeString() </span> provides a string of the type for convenience.
</p>
<div class = "note_block basictext">
    <b> IMPLEMENTATION NOTE </b> The client-side library extracts data from the Service
    (tos-databridge-engine[].exe) through a series of protected kernel objects in the global namespace, 
    namely a read-only shared memory segment and a mutex. The Service receives data messages from the 
    TOS DDE server and immediately locks the mutex, writes them into the shared memory buffer, and 
    unlocks the mutex. At the same time the library is looping through its blocks and item-topic pairs 
    looking to see what buffers have been updated, acquiring the mutex, and reading the buffers, if 
    necessary. The speed at which the looping occurs depends on the UpdateLatency enum value set in the 
    library. The lower the value, the less it waits, the faster the updates.
    <span class = "func_stub"> TOSDB_GetLatency() </span> and 
    <span class = "func_stub"> TOSDB_SetLatency() </span> are the relevant calls. A value of Fastest(0) 
    allows for the quickest refreshes, but can chew up clock cycles - view the relevant CPU% in process 
    explorer or task manager to see for yourself. The default(Fast, 30) or Moderate(300) should be fine 
    for most users.
</div>
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > C/C++ Interface Calls ::: Part 2 - Get Calls </div> 
<div class = subblock1 ">
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Once you've created a block with valid items and topics, at some point you'll 
    want to extract the data that is collected. This is done via the non-administrative TOSDB_Get... calls 
    and is where things can get a little tricky.&nbsp; The two basic techniques are pulling data as: 1) a 
    segment of a data-stream and 2) a frame. 
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Remember a data-stream is all the historical data of the block for a particular 
    item-topic entry.  A block with 3 topics and 4 items has 12 different data-streams each of the size 
    passed to TOSDB_CreateBlock(). The data-stream is indexed thusly: 0 or -(block size) is the most recent 
    value, -1 or (block size - 1) is the least recent.
</p>
<div class = "note_block basictext"> 
    <b> IMPORTANT </b>  When indexing a sub-range it is important to keep in mind both values are INCLUSIVE 
    [ , ]. Therefore a sub-range of a data-stream of size 10 where index begin = 3(-7) and index end = 5(-5) 
    will look like:  [0][1][2]<b style="color:red">[3][4][5]</b>[6][7][8][9]. Be sure to keep this in mind 
    when passing index values as the C++ versions will throw std::invalid_argument() if you pass an ending 
    index of 100 to a stream of size 100.</div>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp; A frame on the other hand does not look at a specific 
    data-stream, rather it spans ALL the topics, or items, or both. Think of all the 
    data-streams as the 3rd dimension of 2-dimensional frames. In theory there can 
    be a frame for each index( for example a frame of all the most recent values or 
    of all the oldest ) but in practice we&#39;ve only implemented the retrieval of the 
    most recent frame because the data is currently structured in a &#39;tick-dependent&#39; 
    rather than a &#39;time-dependent&#39; chronological order, making an index of frames 
    mostly useless.  
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    Let's drill down a bit on some specific 
    calls. First are the single value <span class = "func_stub"> TOSDB_Get&lt; , &gt;() </span> and 
    <span class = "func_stub"> TOSDB_Get[Type]() </span> calls; the former a templatized C++ version, the 
    latter a C version with the required type stated explicitly in the call (e.g. TOSDB_GetDouble() ). The 
    C++ version's first template arg is the value type to return. The client has three options: 1) figure 
    out the type of the data-stream (the type bits are packed in the topic enum, see above) and make the 
    appropriate call; 2) pass in generic_type to receive a custom generic type that knows its own type, 
    can be cast to the relevant type, or can have its as_string() method called; 3) use the specialized 
    std::string version.  The C versions require you to figure the type and make the appropriately named 
    call or call the string version, passing in a char* to be populated with the data 
    ( &lt; TOSDB_STR_DATA_SZ ). Obviously the generic and string versions come with a cost but since n=1 
    it&#39;s insignificant. The C++ version&#39;s second template argument is a boolean indicating whether 
    it should return DateTimeStamp values as well(assuming the block is set for that) while the C version 
    accepts a pointer to a DateTimeStamp struct(pDateTimeStamp) that will be populated with the value
    (pass a NULL value otherwise).
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    In most cases you&#39;ll want more than a single value - use the 
    <span class = "func_stub"> TOSDB_GetStreamSnapshot&lt; , &gt;() </span> and 
    <span class = "func_stub"> TOSDB_GetStreamSnapshot[Type]s() </span> calls. The concept is similar to 
    the individual value TOSDB_Get... calls from above except they return containers(C++) or populate 
    arrays(C) and require a beginning and ending index value. The C calls require you to state the 
    explicit dimensions of the arrays( the string version requires length of the string buffers as well; 
    internally, data moved to string buffers is of maximum size TOSDB_STR_DATA_SZ so no need to allocate 
    larger than that).  DateTimeStamp is dealt with in the same way as above. If NULL is not passed it's 
    array length is presumed to be the same as the other array so make sure you pay attention to what you 
    allocate and pass. The C++ calls are implemented to return either a vector of different types or a 
    pair of vectors(the second a vector of DateTimeStamp), depending on the boolean template argument. 
    Please review the function prototypes in tos_databridge.h and the Glossary section below for a better 
    understanding of the options available.</p>
<div class = "note_block basictext"> 
    <b> IMPLEMENTATION NOTE </b> Internally the data-stream tries to limit what is copied by keeping 
    track of the streams occupancy and finding the MIN( occupancy count, difference between the end and 
    begin indexes +1[since they're inclusive], size of parameter passed in).  For C++ calls that return 
    a container it's possible you may want the sub-stream from index 5 to 50 but if only 10 values have 
    been pushed into the stream it will return a container with values from index 5 to 9. Therefore you 
    should use the GetStreamOccupancy call mentioned in the above section, check the returned object&#39;s 
    size, use its resize method(s), or pass an explicit array to one of the C calls if relying on an 
    object of certain size(length). If you choose the latter keep in mind  the data-stream will NOT 
    copy/initialize the 'tail' elements of the array that do not correspond to valid indexes in the 
    data-stream and the value of those elements should be assumed undefined.
</div>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    It&#39;s likely the stream will grow between consecutive calls. The
    <span class = "func_stub"> TOSDB_GetStreamSnapshot[Type]sFromMarker() </span> calls 
    (C only) guarantee to pick up where the last TOSDB_Get, TOSDB_GetStreamSnanpshot, or 
    TOSDB_GetStreamSnapshotFromMarker call ended (under a few assumptions).&nbsp; 
    Internally the stream maintains a &#39;marker&#39; that tracks the position of the last 
    value pulled; the act of retreiving data and moving the marker can be thought of 
    as a single, &#39;atomic&#39; operation. The *get_size arg will return the size of the 
    data copied, it&#39;s up to the caller to supply a large enough buffer. A negative 
    value indicates the buffer was to small to fit all the data, or the stream is 
    &#39;dirty&#39; . A &#39;dirty&#39; stream means the marker has hit the back of the stream and 
    data between the beginning of the last call and the end of the next will be 
    dropped. To avoid this be sure you use a big enough stream and/or keep the 
    marker moving foward (by using the get calls mentioned above). To determine if 
    the stream is &#39;dirty&#39; use the <span class = "func_stub"> TOSDB_IsMarkerDirty() 
    call</span>. There is no guarantee that a &#39;clean&#39; stream will not become dirty 
    between the call to TOSDB_IsMarkerDirty and the retrieval of stream data, although 
    you can look for a 
    negative *get_size value to indicate this rare state has occured.</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    The three main &#39;frame&#39; calls are 
    GetItemFrame, GetTopicFrame, GetTotalFrame( C++ only ). 
    <span class = "func_stub"> TOSDB_GetItemFrame&lt;&gt;() </span> and
    <span class = "func_stub"> TOSDB_GetItemFrame[Type]s() </span> are used to retrieve the most recent 
    values for all the items of a particular topic. Keep in mind, the frames are only dealing with the the 
    'front' of the block, i.e. index = 0 of all the data-streams. Think of it as finding the specific topic 
    on its axis, then pulling all the values along that row. Because the size of n is limited the C++ calls 
    only return a generic type, whereas the C calls necessarily require the explicitly named call to be 
    made( or the (C-)String version). The C++ calls take one boolean template arg as above. One major 
    difference between the frame calls and the data-stream calls is the former map their values to a 
    string of the relevant topic or item name. For instance, a call of GetItemFrame&lt;true&gt;( ..., BID) 
    for a block with topics: BID, ASK and items: IBM, GE, CAT will return ( "IBM", (val,dts); "GE", 
    (val,dts); "CAT", (val,dts) ); that is, a mapping of item strings to either the value as generic_type, 
    or to a pair of generic_type and DateTimeStamp (depending to the boolean passed to the template).  
    The C calls require pointers to arrays of appropriate type, with the dimensions of the arrays. The 
    value array is required; the second array of strings that is populated with the corresponding 
    labels(item strings in this case) and the third array of DateTimeStamp object are both optional. 
    Remember, where specified the arrays require dimensions to be passed; if not they presume them to be 
    the same as the primary value array(arg 'dest').
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span class = "func_stub"> TOSDB_GetTopicFrame<>() </span> and 
    <span class = "func_stub"> TOSDB_GetTopicFrameStringss() </span> are used to retrieve the most recent 
    values for all the topics of a particular item. Think of it as finding the specific item on its axis, 
    then pulling all the values along that row. They are similar to the GetItemFrame calls from above 
    except for the obvious fact they pull topic values and there is only the one C call, populating an
    array of c-strings. Since each item can have multiple topic values, and each topic value may be of a 
    different type, it's necessary to return strings(C) or generic_types(C++).
</p>
<p class = "subpara1 basictext">
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span class = "func_stub"> TOSDB_GetTotalFrame<>() </span> is the last type 
    of frame call that returns the total frame(the recent values for ALL items AND topics) as a matrix, 
    with the labels mapped to values and  DateTimeStamps if true is passed as the template argument. 
    Because of the complexity of the the matrix, with mapped strings, and possible DateTimeStamp structs 
    included there is only a C++ version. C code will have to iterate through the items or topics and 
    call GetTopicFrame(item) or GetItemFrame(topic), respectively, like the Python Wrapper does. 
</p>
<div class = "note_block basictext"> 
    <b> IMPLEMENTATION NOTE </b> The data-streams have been implemented in an effort to 1) provide 
    convenience by allowing both a generic type and strings to be returned; 2) not make the client pay 
    for features that they don't want to use.(i.e. genericism or DateTimeStamps); 3) take advantage of 
    a type-correcting feature of the underlying data-stream(see the comments and macros in data_stream.hpp);
    4) throw derived exceptions or return error codes depending on the context and language; and 
    5) 
    provide at least one very efficient, 'stream-lined' call for large data requests.<br /><br />
    In order to comply with #5 
    we violate the abstraction of the data block for all the Get.. calls and the 
    interface of the data-stream for the non-generic versions of those same calls. 
    For the former we allow the return of a const pointer to the stream, allowing the client-side back-end to operate 
    directly on the stream. For the latter we provide 'copy(...)' virtual methods of the data-stream that 
    take raw pointer(s) to be populated directly, bypassing generic_type construction and STL overhead.
    <br /><br />
    Not suprisingly, when n is very large the the non-string TOSDB_GetStreamSnapshot[Type]s C calls are the fastest, with 
    the non-generic, non-string TOSDB_GetStreamSnapshot&lt;Type,false&gt; C++ calls just behind.
</div>
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > C/C++ Interface Calls ::: Part 3 - Logging, Exceptions &amp; Stream Overloads</div> 
<div class = subblock1 "> 
<p class = "subpara1 basictext"> 
    &nbsp;&nbsp;&nbsp;&nbsp; 
    The library exports some logging functions that dovetail with its use of 
    custom exception classes. Pass a file-name to <span class = "func_stub"> TOSDB_StartLogging() </span> 
    to begin. <span class = "func_stub"> TOSDB_LogH() </span> and 
    <span class = "func_stub"> TOSDB_Log() </span> will log high and low priority messages, respectively.  
    Pass two strings: a tag that provides a short general category of what's being logged and a detailed 
    description. <span class = "func_stub"> TOSDB_LogEx() </span> is like _LogH with an additional argument 
    generally used for an error code like one returned from GetLastError().  If TOSDB_StartLogging() hasn't 
    been called and a high-priority event(_LogH, _LogEx) is logged the info will be sent to std::cerr.  
    <span class = "func_stub"> TOSDB_Log_Raw_() </span> only takes a single string, doesn't format anything 
    or provide additional information and, more importantly, doesn't block.  
    <span class = "func_stub"> TOSDB_ClearLog() </span> and 
    <span class = "func_stub"> TOSDB_StopLogging() </span> have the expected effects.  
</p>
<p class = "subpara1 basictext">  
    &nbsp;&nbsp;&nbsp;&nbsp;  
    Most of the modules use these logging functions internally.  The files are sent 
    to appropriately named .log files that reside in a /tos-databridge folder in the 'appdata' path for the 
    particular user(the path string returned from the APPDATA environment variable). The service and engine 
    executables, being run by the system account, will write to different paths 
    (&quot;C:/Windows/System32/config/systemprofile/appdata...&quot;) than the modules run by the user.
</p>
<p class = "subpara1 basictext">  
    &nbsp;&nbsp;&nbsp;&nbsp;  
    The library also defines an exception hierarchy, derived from TOSDB_Error and 
    std::exception - categorizing some of the serious errors that may be encountered.  C++ code can catch 
    them and respond accordingly; the base class provides threadID(), processID(), tag(), and info() 
    methods as well as the inherited what() from std::exception. Namespace data_stream 
    (see data_stream.hpp for the implementation details) also provides some exceptions that, when possible, 
    are caught internally and wrapped in TOSDB_Error.
</p>
<p class = "subpara1 basictext"> 
    &nbsp;&nbsp;&nbsp;&nbsp; There are operator&lt;&lt; overloads for most of the custom 
    objects and containers returned by the TOSDB_Get... calls.</p>
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > Glossary of Terminology, Types, Constants, Instantiations, and Specializations of the C/C++ Interface(s) </div> 
<div class = "subpara1 basictext"> 
        
    <ul >        
        <li class = "listitems2 bold"> <div class = "left_col">topics </div><div class = "right_col"> 
            strings or TOS_Topics::TOPICS enums(recommended) of fields to be added (e.g. BID, ASK, LAST ) 
            </div><div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col"> items </div> <div class = "right_col"> 
            strings of symbols to be added (e.g. GE, SPY, GOOG )</div> <div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> data-stream </div><div class = "right_col"> 
            the historical data for each item-topic entry (see data_stream.hpp)  </div><div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col"> frame </div><div class = "right_col"> 
            all the items, topics, or matrix of both, for a particular index( only index of 0 is currently 
            implemented ) </div><div class="cb"></div></li>
        <li class = "listitems2 bold"><br /></li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOS_Topics  </div><div class = "right_col"> 
            a specialization that provides a scoped enum containing all the topics( TOS data fields), a 
            mapping to the relevant strings, and some utilities. This is the recommended way for C++ calling 
            code to pass topics. Inside the high-order bits of the enum value are the type bit constants 
            TPC..[ ] which can be checked directly or via one of the aptly named public utilities </div> 
            <div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">DateTimeStamp </div><div class = "right_col"> 
            struct that wraps the C library tm struct, and adds a micro-second field </div><div class="cb">
            </div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">BufferHead </div><div class = "right_col"> 
            struct that aligns with the front of the Stream Buffers in shared memory providing info on the 
            buffer to the client </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">ILSet<>  </div><div class = "right_col"> 
            wrapper around std::set<> type that provides additional means of construction / copy / move 
            / assignment </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">TwoWayHashMap<>  </div><div class = "right_col"> 
            mapping that allows values to be indexed both ways, using custom hashes, with a thread-safe 
            specialization </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> UpdateLatency </div><div class = "right_col"> 
            Enum of milliseconds values the client library waits before re-checking buffers </div>
            <div class="cb"></div> </li>
        <li class = "listitems2 bold"><br /></li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_type  </div><div class = "right_col"> 
            custom generic type (generic.hpp/cpp) </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_dts_type  </div><div class = "right_col"> 
            pair of generic and DateTimeStamp </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_vector_type  </div><div class = "right_col"> 
            vector of generics </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col">dts_vector_type </div><div class = "right_col"> 
            vector of DateTimeStamps </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_dts_vectors_type  </div><div class = "right_col"> 
            pair of : ( vector of generics, vector of DateTimeStamps ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_map_type  </div><div class = "right_col"> 
            mapping of item/topic strings and generics </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_matrix_type  </div><div class = "right_col">
            mapping of item/topic strings and generic_map_type </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_dts_map_type  </div><div class = "right_col"> 
            mapping of item/topic strings and generic_dts_type </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">generic_dts_matrix_type  </div><div class = "right_col"> 
            mapping of item/topic strings and generic_dts_map_type </div><div class="cb"></div> </li>            
        <li class = "listitems2 bold"> <div class = "left_col">str_set_type  </div><div class = "right_col"> 
            instantiation of ILSet<> for std::string </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col">topic_set_type  </div><div class = "right_col"> 
            instantiation of ILSet<> for TOS_Topics::TOPICS </div> <div class="cb"></div></li>           
        <li class = "listitems2 bold"> <div class = "left_col">def_size_type  </div><div class = "right_col"> 
            default size type for data ( long ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"><div class = "left_col"> ext_size_type  </div><div class = "right_col"> 
            extend size type for data ( long long ) </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col">def_price_type  </div><div class = "right_col"> 
            default price type for data ( float ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">ext_price_type  </div><div class = "right_col"> 
            extended price type for data ( double ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">size_type  </div><div class = "right_col"> 
            explicit size type for Python Wrapper ( unsigned long ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col">type_bits_type </div><div class = "right_col"> 
            bits set in an unsigned char to indicate the underlying type of a TOS_Topics::TOPICS  </div>
            <div class="cb"></div> </li>	
        <li class = "listitems2 bold"><br /></li>		  
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_APP_NAME  </div><div class = "right_col"> 
            name of the DDE Application ( TOS ) </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_COMM_CHANNEL  </div><div class = "right_col"> 
            name of the DynamicIPC communication mechanism </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_LOG_PATH  </div><div class = "right_col"> 
            path derived from users and system's %APPDATA%, for log files to be sent </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_INTGR_BIT  </div><div class = "right_col"> 
            type bits for an integral data type </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_QUAD_BIT  </div><div class = "right_col"> 
            type bits for an 8-byte data type </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_STRING_BIT  </div><div class = "right_col"> 
            type bits for a string data type </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_TOPIC_BITMASK </div><div class = "right_col"> 
            logical OR of all the type bits  </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_SIG_ADD</div><div class = "right_col"> 
            message sent to the data engine to add a stream/connection to TOS </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_REMOVE</div><div class = "right_col"> 
            message sent to the data engine to remove a stream/connection to TOS </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_PAUSE  </div><div class = "right_col"> 
            message sent to the data engine from the service to pause</div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_CONTINUE  </div><div class = "right_col"> 
            message sent to the data engine from the service to continue </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_STOP  </div><div class = "right_col"> 
            message sent to the data engine from the service to stop </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_DUMP  </div><div class = "right_col"> 
            message sent to the data engine to dump the buffer data </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_GOOD  </div><div class = "right_col"> 
            signal sent between data engine and service </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"><div class = "left_col"> TOSDB_SIG_BAD  </div><div class = "right_col"> 
            signal sent between data engine and service </div> <div class="cb"></div></li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_MIN_TIMEOUT  </div><div class = "right_col"> 
            minimum timeout period for the locks/latches/signals used to for internal communication / 
            synchronization </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_DEF_TIMEOUT  </div><div class = "right_col"> 
            default timeout for above </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_SHEM_BUF_SZ </div><div class = "right_col"> 
            size in bytes of the buffer that the data engine will write to</div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_MAX_STR_SZ </div><div class = "right_col"> 
            maximum string size for client input (items, topics etc) among other strings</div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_STR_DATA_SZ</div><div class = "right_col"> 
            maximum size of char buffer pulled from DDE server and pushed into a data-stream of std::strings 
            (everything larger is truncated)  </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_BLOCK_ID_SZ</div><div class = "right_col"> 
            maximum string size for the name/ID of a TOSDBlock  </div><div class="cb"></div> </li>
        <li class = "listitems2 bold"> <div class = "left_col"> TOSDB_DEF_LATENCY </div><div class = "right_col"> 
            the default UpdateLatency (Moderate= 300 milleseconds)  </div><div class="cb"></div> </li>
</ul>    
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > Clean... Exit... Close... Stop... </div> 
<div class = subblock1 "> 
<p class = "subpara1 basictext"> 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Still in flux is the best protocol(s) for exiting some or all of the TOSDB 
    modules. One complicating factor is the myriad states the entire TOSDB system 
    can be in.
</p>
<p class = "subpara1 basictext"> 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    Assuming everything is up and running you really want to avoid shutting down the  
    TOS platform and/or the Service while your client code is running. The former is particularly troubling 
    because, as it stands, the Service has not implemented a mechanism for handling a server induced shutdown, 
    it won't deallocate the resources held for the particular conversations initiated. The latter will free the 
    resources but leave the client-code stranded. </p>
<p class = "subpara1 basictext"> 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    As a general rule follow this order: 1) Clean up: close blocks, call clean_up etc. 
    2) Exit your program. 3) Stop the Service 4) Close TOS platform. Once you've done #1 the order of 2-4 is 
    much less important. To avoid having to restart the service it can be left running. If step #1 is not 
    completed properly it may continue to pull data off the platform though.Rememberr, the Service is built to 
    work with multiple instantiations of the client library, maintaining ref-counts to shared resources - just 
    because you cleaned up doesn't mean another instance has. As always you can open the debug shell, connect, 
    and use DumpBufferStatus to see if there are any resources dangling. 
</p>
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > The Python Wrapper In A Nutshell </div>
<div class = subblock1 "> 
<p class = "subpara1 basictext"> 
   &nbsp;&nbsp;&nbsp;&nbsp; As mentioned the python wrapper is a simpler, yet still robust, way to get 
   started with the underlying library. To use it you&#39;ll still need all the underlying modules 
   mentioned above, and you&#39;ll need to create and start the Windows Service mentioned in &#39;
   Getting Started&#39; as well. (tosdb.py was only written to be compatible with the &#39;new&#39; 
   python ( v3.0 + ) and it&#39;s only been tested on v3.3.0 64bit.&nbsp; If you want backward 
   compatibility you&#39;ll have to make the necessary changes. ). 
</p>
<div class = "note_block basictext"> 
    <strong>IMPLEMENTATION NOTE</strong> tosdb.py uses a library called ctypes.py to load the 
    tos-databridge[].dll library(the main one discussed above). That library requires another library
     to be loaded (_tos-databridge-shared[].dll ) which it expects to be in one of a number of locations; 
     that's why we manually copied it to your %WINDIR% directory earlier.                
</div>

    <div class = "listitems3">  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  First, it's important if 
        installing on a windows system, you make sure the version of the binary running 
    in the windows services is the same as the one python is going to run. Python is going to pick 
    the version for you that matches its own build.  Before you create/run the service described in 
    the 'Getting Started' section open a python shell and look to see if it says 32 bit or 64 bit on 
    the top. If it says 32 you want to use the binaries that end like this ...blah-blah-x86.dll 
    (NOT the -x86_d.dll version).  After you get the service up and running open up task manager 
    or some such program that lets you view the image name of the exe's and make sure its the 
    correct version. </div>

    <div class = "listitems3"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; From a command prompt navigate to the 
        tos-databridge/python directory. The command <em>&#39;python setup.py install</em>&#39; 
        builds and installs the necessary package/modules depending on the platform 
        you&#39;re installing it on. Remeber, if installing on a non-windows system to 
        utilize the virtual interface you&#39;ll still need to install on a (physically or 
        virtually) networked windows sytem. </div>

    <div class = "note_block basictext"> 
    <strong>TROUBLESHOOTING</strong> As mentioned in the above implementation note 
    tosdb.py uses ctypes.py to access the underlying library. But, because of how some of the constants
    are necessarily defined in the underlying library, and because at some point we might want to
    migrate some of the low-level functionality away from ctypes, we created a C (really C++) extension 
    module called _tosdb.cpp/pyd to provide some of these constants as well as a tuple named TOPICS, 
    that provides all the currently valid topics that can be passed to the TOS DDE Server. When you run 
    the install command python's distutils library will attempt to build _tosdb.pyd from 
    _tosdb.cpp, installing it alongside the tosdb package.  
    <br /><br />
    ** If you are not comfortable with VisualStudio or building python modules, and you are using 
    Python 3.3 or 3.4, you can simply copy the tosdb.py file and the _tosdb... file that matches
    your python(for instance _tosdb-x86-3.pyd is for Python 3.3 32bit ), paste them into your python 
    PATH (e.g. C:/Python33 or C:/Python33/site-packages), rename the second file (_tosdb...) to
    '_tosdb.pyd' and skip the rest. 
    <br /><br />
    A number of things outside of our control may create issues with this step. A few suggestions, 
    followed by some alternatives: 
        <br />
    <br />1) If compiling on/for windows be sure you have the necessary VisualStudio build tools, typically found in a folder 
    stored in an environment variable like %VS100COMNTOOLS%.<br />
    <br /> 2) If using VisualStudio2012 your tools will be found in %VS110COMNTOOLS% but distutils 
    will look for variable %VS100COMNTOOLS% (python 3.3 and 3.4) or variable %VS90COMNTOOLS% 
    (earlier versions) so we need to trick it by entering 'SET VS100COMNTOOLS=%VS110COMNTOOLS%' 
    (or SET VS90... depending on the version) at a command prompt. 
        <br />
    <br /> 3) If compiling 64-bit, setup may raise a ValueError when distutils tries to pass the 
    'amd64' arg to vcvarsall.bat; it needs the 'x86_amd64' arg instead. A simple hack: 
    open msvc9compiler.py in the distutils package, go down the the function query_vcvarsall() 
    ~ line# 250 and hard-code <em>'arch = "x86_amd64" if arch == "amd64" else arch'</em> before Popen is called.
        <br />
     <br />4) Initially when trying to build I kept running into an error that simply returned "error: " 
    (which, in the history of bad error messages, is one of my favorites). It turns out the 'auto-sandbox' 
    feature of COMODO firewall was causing a suprocess.Popen() call to fail. If you run into similar 
    problems check your firewall/AV settings or privilege level.
        The same is true if you get TOSDB_VirtualizationErrors while try to use the the 
        virtual interface.<br /><br />
    If there is a problem the setup script should output some information on what it is and, if 
    _tosdb.pyd wasn't built, ask if you want to try installing a pre-compiled _tosdb.pyd binary to avoid 
    the whole build process. In the /python directory we&#39;ve include some pre-compiled 
        files(mentioned above) that the setup script will try to match with your python 
        version, rename to _tosdb.pyd, and move to the python root directory. You can do 
        this manually just remember to rename the file &#39;_tosdb.pyd&#39;. We&#39;ve included 32 
        and 64 bit versions for python 3.3 and 3.4. If you&#39;re using a different version 
        you&#39;ll have to build your own.<br /><br />
        <b><strong>THE NUCLEAR OPTION</strong></b>: you can get away with not using _tosdb.pyd by following these steps 1) comment 
    out or remove the 'from _tosdb import*' at the top of tosdb/_common.py, 2) open _tosdb.cpp and find the 
    global const char* definitions (INTGR_BIT, DEF_TIMEOUT etc.), 3) for all those strings, except TOPICS, 
    declare variables of the same name in the global scope, right after all the import statements, in 
        tosdb/_common.py, and 4) open the tos_databridge.h header to find what those variables you just declared 
    should be defined as. In the header they all have a TOSDB_ prefix. For example, the first variable 
    would be INTGR_BIT; go to tos_databridge.h and see that TOSDB_INTGR_BIT is #defined as 0x80, go to 
    the top of tosdb/_common.py and enter 'INTGR_BIT = 0x80'. Do the same for all the others, except TOPICS - 
    you won't have access to the TOPICS tuple.
</div>
<div class = "listitems3"> tosdb/ is structured as a package with the bulk of its 
    code in __init__.py and _win.py , the latter holding the non-portable parts that 
    __init__.py will import if it determines it&#39;s being run on a windows sytem. This 
    structure allows you to simply import the package (import tosdb) or, if needed, 
    extensions like intervalize.py (from tosdb import intervalize). There are a couple of ways to start tosdb. You can run it directly in 
    interactive mode passing the appropriate arguments or open a shell or GUI and import it 
    like a regular library. However you start it eventually you'll have to initialize it, which 
    requires the path or general location of the underlying library it&#39;s going to load
    (the tos-databridge[].dll) or the root directory it&#39;s going to search in for the latest 
    version. ersion. <strong> Please see the tutorial in /docs for a walk-through with screen-shots.</strong></li>
   </div>

<div class = "note_block basictext"> 
    <strong>IMPORTANT</strong>&nbsp;  There is a minor issue with how python uses the underlying library 
    to deallocate shared resources used by it and the Service. Generally calls like TOSDB_CloseBlock and 
    TOSDB_RemoveTopic handle this on a case by case basis or the DLL's DllMain method attemptts to close the 
    necessary resources and signal the Service with the corresponding requests when the library is freed.
    <br /><br />
    We&#39;ve provided two ways for doing this in the tosdb.py. The first is the granular methods that 
    make the underlying TOSDB_ calls for you via the TOS_DataBlock remove_items() and remove_topics() methods
    and the object&#39;s __del__() method which calls the underlying TOSDB_CloseBlock function. The problem 
    with the __del__() method is two-fold: 1) a del call only decrements the ref-count of the object, it 
    doesn&#39;t necessarily call __del__ and the underlying CloseBlock call, and 2) on exit() the underlying 
    call is dependent on the order in which globals are deleted and may fail, for this or other reasons. 
    In some cases, as in resetting IDLE, there appears to be no attemptt to even call the objects __del__ 
    methods or free the underlying library.
    <br /><br />
    <strong>Because of all this WE STRONGLY RECOMMEND you call clean_up() before exiting to be sure all the 
    shared resources have been properly dealt with.</strong>  If this is not possible, the program 
    terminates abruptly for instance, there's a good chance you've got dangling BufferStreams
    (shared mem segments) and Mutants(mutexes).  You can check this by opening the tos-databridge-shell[].exe 
    calling Connect and then DumpBufferStatus to create a file in the Systems appdata folder to see what 
    resources are held by the Service. You'll probably want to restart the Service(see 'Getting Started' 
    above) if your program had more than a small number of trivial TOS_DataBlocks.
</div>
</div>
</div>

<div class = "block1 basictext" >
<div class = "subheader1" > Important Details and Provisos</div> 
<div class = subblock1 ">
<ul >      
   <li class = "listitem2"> <strong>DDE Data:</strong> It&#39;s important to realize that we (us, you, 
    this code, and yours) are at the mercy of the TOS platform, the DDE technology, and TOS&#39;s 
    implementation of it. DDE has been replaced by a number of better Windows technologies but it&#39;s 
    the public interface that TOS exposes so it&#39;s what we&#39;re using. You may notice the streams 
    of data - particularly on symbols with very high trading volume - will not match the Time &amp; 
    Sales perfectly.&nbsp; 
    If you take a step back and aggregate the data in more usable forms this really shouldn&#39;t be 
    an issue.&nbsp; Another 
    way we are at the mercy of the DDE server is that fields like last price and last size are two
    different topics.  That means they are changing at slightly different times with slightly different 
    time-stamps even if they are the correct pairing. To get around this we can write (python) code 
    like this to simulate a live-stream : 
    <code><br/>
        &gt;&gt;&gt; vol = 0<br />
        &gt;&gt;&gt; print(&quot;price&quot;,&quot; : &quot;,&quot;size&quot;)&nbsp; <br/>
        >>> while(not 
        closeTS): <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = db.get("GOOG","VOLUME") <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = db.get("GOOG","LAST") <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(v != vol): <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        print(p,&quot; : &quot;,v - vol) <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vol = v <br/>
        ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(.1) 
    <br/></code></li>

   <li class = "listitem2"> <strong>Case-Sensitivity:</strong> Case Sensitivity is a minor issues with 
   how Item values are handled. The underlying C/C++ library are case-sensitive; it's up to the client 
   to make sure they are passing case consistent item strings.  The Python wrapper is case-insensitive; 
   on receiving item and topic strings they are converted to upper-case by default. </li>

   <li class = "listitem2"> <strong>Closing Large Blocks:</strong> Currently Closing/Destroying large 
   blocks(1,000,000+ combined data-stream elements) involves a large number of internal 
   deallocations/destructions and becomes quite CPU intensive. The process is spun-off into its own thread 
   but this may fail, returning to the main thread when the library is being freed, or block the python 
   interpreter regardless of when or how it&#39;s called. One alternative is to utilize TOSDB_SetBlockSize() 
   / set_block_size() to massively shrink the block/data-streams before closing the block. Internally the 
   data-stream deque objects calls .resize() and .shrink_to_fit() but there are no guarantees as to if and 
   when the actual memory will be deallocated so use caution when creating large blocks, especially those 
   with many topics and items as the number of data-streams is a multiple of the two.</li>

    <li class = "listitem2"> <strong>Block Size and Memory:</strong> As mentioned you need to use some 
    sense when creating blocks. As a simple example: let's say you want LAST,BID,ASK for 100 symbols. If you
    were to create a block of size 1,000,000, WITHOUT DateTime, you would need to allocate over 2.4 GB of 
    memory - not good. As a general rule keep data-streams of similar desired size in the same block, and use
    new blocks as necessary. In our example if you only need 1,000,000 LAST elems for 10 items and 100 for 
    everything else create 2 blocks: 1) a block of size 1,000,000 with those 10 items and the topic LAST; 2) 
    a block of size 100 with all 100 items and the three topics. Then you would only need a little over 80 MB. 
    Really you could create three blocks to avoid any overlap but in this case its only a minor performance 
    and space improvement and not worth worth the inconvenience. </li>    

    <li class = "listitem2"> <strong>Inter-Process Communication(IPC):</strong> The current means of 
    IPC is a complicated mess. It uses a pair of master/slave objects that share two duplexed 
    named pipes and a shared memory segment.&nbsp;  
    Because of all the moving parts and the waiting / blocking involved there will be 
        connection issues while trying to debug as one thread hits a break-point causing 
        part of the IPC mechanism&#39;s wait to expire. Internally the client library 
        continually calls the masters -&gt;connected() method which is built to fail 
        easily, for any number of reasons. Debugging certain areas of code will make 
        this connected call fail, shuting down communication between master and slave. 
        In certain cases, where one side of the connection is waiting on a message via a 
        pipe you&#39;ll get a deadlock. </li>

    <li class = "listitem2"> <strong>Asymmetric Responsibilities &amp; Leaks:</strong> An issue related 
    to the previous is the fact that the connection probing only works one way, from master to slave. The 
    slave(which is owned by the Service) therefore may know that one of the clients isn&#39;t there and 
    handle a disconnection, it just doesn&#39;t know what stream objects they are responsible for. 
    Internally all it does st keep a ref-count to the streams it&#39;s been asked to create and 
    obviously write the necessary data into the appropriate shared memory segments. To see the status of the service and if there are stranded or dangling 
    streams open up the debug shell and use <span class = "func_stub">TOSDB_DumpSharedBufferStatus</span> 
        to dump all the current stream information to a file in the same directly as the 
        internal logs(see above) for debugging. Until a number of these issues are 
        worked out it&#39;s recommended to stop and re-start the Service whenever a client 
        executable that has active blocks and streams fails in a way that may not allow 
        it to send TOSDB_SIG_REMOVE messages to the Service.</li>

    <li class = "listitem2"> <strong>DateTimeStamp:</strong> There are some issues with the DateTimeStamps 
    attached to data. The first and most important is THESE ARE NOT OFFICIAL STAMPS FROM THE EXCHANGE, they 
    are manually created once the TOS DDE server returns the data. Secondly they use the system clock to 
    assure high_resolution( the micro-seconds field) and therefore there is no guarantee that the clock 
        is accurate or won't change between stamps, as is made by the STL's std::steady_clock.  We've also had some issues 
    converting high resolution time-points to C time when micro_seconds are close to 0 that we think is 
    solved by casting the micro_seconds duration to seconds and adding that back to the epoch before 
    converting to C time. </li>

    <li class = "listitem2"> <strong>Bad Items &amp; Topics: </strong>The implementation can easily handle 
    bad topics passed to a call since it has a large mapping of the allowed topic strings mapped to enum 
    values for TOS_Topics. If a passed string is mapped to a NULL_TOPIC then it can be rejected, or even 
    if it is passed it won't get a positive ACK from the server and should be rejected. Bad item strings 
    on the other hand are a bit of a problem.  The DDE server is supposed to respond with a negative ACK 
    if the item is invalid but TOS responds with a positive ACK and a 'N/A' string. If you look in the 
    internally generated engine.log file after passing a bad item you may see entries like "invalid stod 
    argument" which is the engine trying to convert that N/A into the appropriate numerical type. Currently
    it's up to the user to deal with passing bad Items. Obviously this is not ideal but hey, that's life.</li>

    <li class = "listitem2"> <strong>Pre-Caching: </strong>As mentioned earlier the block requires at 
    least one valid topic AND item, otherwise it can't hold a data-stream. Because of this if only 
    items(topics) are added, or all topics(items) are removed, any of those, or the remaining, 
    items(topics) are held in a pre-cache which is then emptied when a valid topic(item) is added. 
    This has two important consequences: 1) pre-cached entries are assumed to be valid until they come 
    out and are sent to the engine and 2) when using the set of TOSDB_Get...[Name] C/C++ calls or 
    get_items/topics() python calls you will NOT see pre-cached items.  This can be particularly 
    confusing if you remove all the items from a block and then want to check what topics remain as they 
    have all been removed until an item is re-entered. Currently there are C++ calls to check the 
    pre-cached but not C or python versions. </li>

    <li class = "listitem2"> <strong>SendMessage vs. SendMessageTimeout</strong>: To initiate a topic 
    with the TOS server we should send out a broadcast message via the SendMessage() system call. This call 
    is built to block to insure the client has had a chance to deal with the ACK message. For some reason, 
    it's deadlocking, so we've been forced to use SendMessageTimeout() with an arbitrary 500 millisecond 
    timeout. Therefore until this gets fixed adding topics will introduce an amount of latency in 
    milliseconds = 500 x # of topics. </li>

    <li class = "listitem2"> <strong>Stream Nomenclature</strong>: Somewhat stupidly we termed the IPC 
    data-buffers where all the DDE data is written 'Streams', see AddStream in engine.cpp. These
    are not to be confused with the data-streams that are collected in the blocks which store the 
    client specified amounts of data. At some point we will change the names to avoid confusion but we'll
    try use data-streams to refer to ones in the block and Streams or BufferStreams to refer to the others.</li>

    <li class = "listitem2"> <strong>size_type</strong>: Throughout you may see the use of a size_type 
    in some ugly and seemingly unnecessary casts. Since we are creating 32 and 64 bit binaries which 
    define size_t differently we wanted a guaranteed byte width for python code passing size and 
    pointer-to-size arguments through ctypes. </li>

    <li class = "listitem2"> <strong>Concurrency:</strong> TOSDB attemptts to manage and synchronize 
    multiple threads, processes, and shared resources while providing a set of substantive guarantees 
    for calling the underlying library functions from multiple threads. Unfortunately the library has 
    not undergone enough testing to make any such guarantees, despite having the framework in place. </li>
</ul>
</div>
</div>

</div>

</div>

<footer style="text-align:center" > Copyright (C) 2014 Jonathon Ogden </footer>

</body>
</html>
